<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Chaojie&#x27;s Home ✍️ - 算法</title>
    <subtitle>The place where Chaojie writes</subtitle>
    <link href="https://chaojie.fun/tags/suan-fa/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://chaojie.fun"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2020-08-28T15:17:05+08:00</updated>
    <id>https://chaojie.fun/tags/suan-fa/atom.xml</id>
    <entry xml:lang="en">
        <title>Lock Free是什么</title>
        <published>2020-08-28T15:17:05+08:00</published>
        <updated>2020-08-28T15:17:05+08:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://chaojie.fun/articles/lock-free-shi-shen-me/" type="text/html"/>
        <id>https://chaojie.fun/articles/lock-free-shi-shen-me/</id>
        <content type="html">&lt;p&gt;什么是Lock-Free？&lt;&#x2F;p&gt;
&lt;p&gt;在并发访问某个资源的实现中，经常利用锁机制来保证对资源的正确访问。但是锁机制的问题在于会出先死锁、活锁或者线程调度优先级被抢占等问题，同时锁的增加和释放都会消耗时间，导致性能问题。&lt;&#x2F;p&gt;
&lt;p&gt;Lock-Free指的是不通过锁机制来保证资源的并发访问。也就是说线程间不会相互阻塞了。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;shiniao.fun&#x2F;images&#x2F;lockfree.png&quot; alt=&quot;lock-free&quot; &#x2F;&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;实现Lock-Free常见的解决办法是利用CAS操作，CAS是啥？&lt;&#x2F;p&gt;
&lt;p&gt;CAS（Compare and Swap）是一种原子操作，原子很好理解，不可分割（比如原子事务），原子操作意味着CPU在操作内存时（读写）要么一次完成，要么失败，不会出现只完成一部分的现象。现代CPU对原子的读写操作都有相应的支持，比如X86&#x2F;64架构就通过CAS的方式来实现，而ARM通过LL&#x2F;SC（Load-Link&#x2F;Store-Conditional）来实现。&lt;&#x2F;p&gt;
&lt;p&gt;在Go语言中，可通过 atomic 包中的 CompareAndSwap** 方法来编程实现CAS：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;CompareAndSwapPointer&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;addr &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unsafe&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Pointer&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;old&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;new unsafe&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Pointer&lt;&#x2F;span&gt;&lt;span&gt;) (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;swapped &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;使用CAS的过程中有一个问题，考虑如下状况：&lt;&#x2F;p&gt;
&lt;p&gt;如果线程1读取共享内存地址得到A，这时候线程2抢占线程1，将A的值修改为B，然后又改回A，线程1再次读取得到A，虽然结果相同，但是A已经被修改过了，这个就是&lt;strong&gt;ABA问题&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;一种办法是通过类似版本号的方式来解决，每次更新的时候 counter+1，比如对于上面的问题，在线程2修改的时候，因为增加了版本号，导致修改前后的A值并不相同：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;1A--2B--3A
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在论文&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.rochester.edu&#x2F;u&#x2F;scott&#x2F;papers&#x2F;1996_PODC_queues.pdf&quot;&gt;《 Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms》&lt;&#x2F;a&gt; 中，描述了一种利用CAS的Lock-Free 队列的实现，通过 &lt;strong&gt;counter 机制&lt;&#x2F;strong&gt;解决了CAS中的ABA问题，并且给出了详细的伪代码实现，可查看论文中的详细介绍。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;structure pointer_t {ptr: pointer to node_t, count: unsigned integer}
&lt;&#x2F;span&gt;&lt;span&gt; structure node_t {value: data type, next: pointer_t}
&lt;&#x2F;span&gt;&lt;span&gt; structure queue_t {Head: pointer_t, Tail: pointer_t}
&lt;&#x2F;span&gt;&lt;span&gt; 
&lt;&#x2F;span&gt;&lt;span&gt; initialize(Q: pointer to queue_t)
&lt;&#x2F;span&gt;&lt;span&gt;    node = new_node()		&#x2F;&#x2F; Allocate a free node
&lt;&#x2F;span&gt;&lt;span&gt;    node-&amp;gt;next.ptr = NULL	&#x2F;&#x2F; Make it the only node in the linked list
&lt;&#x2F;span&gt;&lt;span&gt;    Q-&amp;gt;Head.ptr = Q-&amp;gt;Tail.ptr = node	&#x2F;&#x2F; Both Head and Tail point to it
&lt;&#x2F;span&gt;&lt;span&gt; 
&lt;&#x2F;span&gt;&lt;span&gt; enqueue(Q: pointer to queue_t, value: data type)
&lt;&#x2F;span&gt;&lt;span&gt;  E1:   node = new_node()	&#x2F;&#x2F; Allocate a new node from the free list
&lt;&#x2F;span&gt;&lt;span&gt;  E2:   node-&amp;gt;value = value	&#x2F;&#x2F; Copy enqueued value into node
&lt;&#x2F;span&gt;&lt;span&gt;  E3:   node-&amp;gt;next.ptr = NULL	&#x2F;&#x2F; Set next pointer of node to NULL
&lt;&#x2F;span&gt;&lt;span&gt;  E4:   loop			&#x2F;&#x2F; Keep trying until Enqueue is done
&lt;&#x2F;span&gt;&lt;span&gt;  E5:      tail = Q-&amp;gt;Tail	&#x2F;&#x2F; Read Tail.ptr and Tail.count together
&lt;&#x2F;span&gt;&lt;span&gt;  E6:      next = tail.ptr-&amp;gt;next	&#x2F;&#x2F; Read next ptr and count fields together
&lt;&#x2F;span&gt;&lt;span&gt;  E7:      if tail == Q-&amp;gt;Tail	&#x2F;&#x2F; Are tail and next consistent?
&lt;&#x2F;span&gt;&lt;span&gt;              &#x2F;&#x2F; Was Tail pointing to the last node?
&lt;&#x2F;span&gt;&lt;span&gt;  E8:         if next.ptr == NULL
&lt;&#x2F;span&gt;&lt;span&gt;                 &#x2F;&#x2F; Try to link node at the end of the linked list
&lt;&#x2F;span&gt;&lt;span&gt;  E9:            if CAS(&amp;amp;tail.ptr-&amp;gt;next, next, &amp;lt;node, next.count+1&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt; E10:               break	&#x2F;&#x2F; Enqueue is done.  Exit loop
&lt;&#x2F;span&gt;&lt;span&gt; E11:            endif
&lt;&#x2F;span&gt;&lt;span&gt; E12:         else		&#x2F;&#x2F; Tail was not pointing to the last node
&lt;&#x2F;span&gt;&lt;span&gt;                 &#x2F;&#x2F; Try to swing Tail to the next node
&lt;&#x2F;span&gt;&lt;span&gt; E13:            CAS(&amp;amp;Q-&amp;gt;Tail, tail, &amp;lt;next.ptr, tail.count+1&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt; E14:         endif
&lt;&#x2F;span&gt;&lt;span&gt; E15:      endif
&lt;&#x2F;span&gt;&lt;span&gt; E16:   endloop
&lt;&#x2F;span&gt;&lt;span&gt;        &#x2F;&#x2F; Enqueue is done.  Try to swing Tail to the inserted node
&lt;&#x2F;span&gt;&lt;span&gt; E17:   CAS(&amp;amp;Q-&amp;gt;Tail, tail, &amp;lt;node, tail.count+1&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt; 
&lt;&#x2F;span&gt;&lt;span&gt; dequeue(Q: pointer to queue_t, pvalue: pointer to data type): boolean
&lt;&#x2F;span&gt;&lt;span&gt;  D1:   loop			     &#x2F;&#x2F; Keep trying until Dequeue is done
&lt;&#x2F;span&gt;&lt;span&gt;  D2:      head = Q-&amp;gt;Head	     &#x2F;&#x2F; Read Head
&lt;&#x2F;span&gt;&lt;span&gt;  D3:      tail = Q-&amp;gt;Tail	     &#x2F;&#x2F; Read Tail
&lt;&#x2F;span&gt;&lt;span&gt;  D4:      next = head.ptr-&amp;gt;next    &#x2F;&#x2F; Read Head.ptr-&amp;gt;next
&lt;&#x2F;span&gt;&lt;span&gt;  D5:      if head == Q-&amp;gt;Head	     &#x2F;&#x2F; Are head, tail, and next consistent?
&lt;&#x2F;span&gt;&lt;span&gt;  D6:         if head.ptr == tail.ptr &#x2F;&#x2F; Is queue empty or Tail falling behind?
&lt;&#x2F;span&gt;&lt;span&gt;  D7:            if next.ptr == NULL  &#x2F;&#x2F; Is queue empty?
&lt;&#x2F;span&gt;&lt;span&gt;  D8:               return FALSE      &#x2F;&#x2F; Queue is empty, couldn&amp;#39;t dequeue
&lt;&#x2F;span&gt;&lt;span&gt;  D9:            endif
&lt;&#x2F;span&gt;&lt;span&gt;                 &#x2F;&#x2F; Tail is falling behind.  Try to advance it
&lt;&#x2F;span&gt;&lt;span&gt; D10:            CAS(&amp;amp;Q-&amp;gt;Tail, tail, &amp;lt;next.ptr, tail.count+1&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt; D11:         else		     &#x2F;&#x2F; No need to deal with Tail
&lt;&#x2F;span&gt;&lt;span&gt;                 &#x2F;&#x2F; Read value before CAS
&lt;&#x2F;span&gt;&lt;span&gt;                 &#x2F;&#x2F; Otherwise, another dequeue might free the next node
&lt;&#x2F;span&gt;&lt;span&gt; D12:            *pvalue = next.ptr-&amp;gt;value
&lt;&#x2F;span&gt;&lt;span&gt;                 &#x2F;&#x2F; Try to swing Head to the next node
&lt;&#x2F;span&gt;&lt;span&gt; D13:            if CAS(&amp;amp;Q-&amp;gt;Head, head, &amp;lt;next.ptr, head.count+1&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt; D14:               break             &#x2F;&#x2F; Dequeue is done.  Exit loop
&lt;&#x2F;span&gt;&lt;span&gt; D15:            endif
&lt;&#x2F;span&gt;&lt;span&gt; D16:         endif
&lt;&#x2F;span&gt;&lt;span&gt; D17:      endif
&lt;&#x2F;span&gt;&lt;span&gt; D18:   endloop
&lt;&#x2F;span&gt;&lt;span&gt; D19:   free(head.ptr)		     &#x2F;&#x2F; It is safe now to free the old node
&lt;&#x2F;span&gt;&lt;span&gt; D20:   return TRUE                   &#x2F;&#x2F; Queue was not empty, dequeue succeeded
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;除此之外，该论文还给出了一种two-lock的并发队列实现，通过在Head和Tail分别添加锁，来保证入队和出队的完全并发操作。&lt;&#x2F;p&gt;
&lt;p&gt;Lock-Free常用来实现底层的数据结构，比如队列、栈等，本文比较了使用单锁机制的队列实现和参考上述论文的Lock-Free队列实现，在 1&amp;lt;&amp;lt;12 个节点的出队入队中，两种算法实现的性能测试结果如下图所示：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;shiniao.fun&#x2F;images&#x2F;benchmark.png&quot; alt=&quot;性能测试&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;可以看到，随着处理器个数的增加，队列的Lock-Free算法一直稳定在200ns&#x2F;op，性能更佳，而使用锁的算法耗时要高出一倍。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码实现参考：&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;github.com&#x2F;rilkee&#x2F;distributed&#x2F;queue&#x2F;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;参考文献：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;http:&#x2F;&#x2F;preshing.com&#x2F;20120612&#x2F;an-introduction-to-lock-free-programming&#x2F;&lt;&#x2F;li&gt;
&lt;li&gt;Michael, M. M., &amp;amp; Scott, M. L. (1996). Simple, fast, and practical non-blocking and blocking concurrent queue algorithms. Proceedings of the Annual ACM Symposium on Principles of Distributed Computing, 267–275. https:&#x2F;&#x2F;doi.org&#x2F;10.1145&#x2F;248052.248106&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
    </entry>
    <entry xml:lang="en">
        <title>分布式缓存中一致性hash算法原理解析与实现</title>
        <published>2019-11-22T15:34:42+08:00</published>
        <updated>2019-11-22T15:34:42+08:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://chaojie.fun/articles/fen-bu-shi-huan-cun-zhong-yi-zhi-xing-hash-suan-fa-yuan-li-jie-xi-yu-shi-xian/" type="text/html"/>
        <id>https://chaojie.fun/articles/fen-bu-shi-huan-cun-zhong-yi-zhi-xing-hash-suan-fa-yuan-li-jie-xi-yu-shi-xian/</id>
        <content type="html">&lt;p&gt;分布式缓存服务中，提供缓存服务的节点可能有很多个。在单机缓存服务中，数据被缓存的流程是这样的：&lt;&#x2F;p&gt;
&lt;p&gt;第一次查询数据时首先从源数据查询（比如数据库），找到之后，同时放入缓存服务器中，下次查询同样的数据时会直接从缓存服务器上查找。&lt;&#x2F;p&gt;
&lt;p&gt;但是缓存服务器一般不太可能是单机的，往往有多个节点。转换为分布式之后，会出现一些问题。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-ti-yi-shu-ju-rong-yu&quot;&gt;问题一数据冗余&lt;&#x2F;h2&gt;
&lt;p&gt;考虑一下，单机服务的时候，利用LRU算法实现缓存的存取，一个key对应一个数据value。分布式条件下，如果只是单纯的增加节点，这次查找key对应的数据在A节点上，下次查找的时候却在B服务器上。同一个key有多个缓存，完全没必要嘛，这样就是数据冗余了。&lt;&#x2F;p&gt;
&lt;p&gt;怎么解决？&lt;&#x2F;p&gt;
&lt;p&gt;利用哈希。首先对key值hash，然后利用节点数取余。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;h = hash(key) %len(node)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样同一个key的数据只会被一个节点缓存。很awesome有没有。&lt;&#x2F;p&gt;
&lt;p&gt;But，我不可能一直是这几个节点呀，万一有的节点挂了呢，或者我要添加节点呢？&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-ti-er-rong-cuo-xing-he-kuo-zhan-xing&quot;&gt;问题二容错性和扩展性&lt;&#x2F;h2&gt;
&lt;p&gt;如果有节点挂了或者新增节点，都会导致&lt;strong&gt;len(node)&lt;&#x2F;strong&gt; 的变化，那么利用hash计算出来的值跟之前的就不一样。这样导致新增或者删除一个节点，之前的所有缓存都失效了！我的天哪！！！&lt;&#x2F;p&gt;
&lt;p&gt;这种问题就是 &lt;strong&gt;缓存雪崩&lt;&#x2F;strong&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;怎么办呢？利用一致性hash算法。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;一致性哈希算法（Consistent Hashing）最早在论文《&lt;a href=&quot;http:&#x2F;&#x2F;www.akamai.com&#x2F;dl&#x2F;technical_publications&#x2F;ConsistenHashingandRandomTreesDistributedCachingprotocolsforrelievingHotSpotsontheworldwideweb.pdf&quot;&gt;Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web&lt;&#x2F;a&gt;》中被提出。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;它的原理是，把所有的hash值空间（就是上面公式计算出来的h）看成是一个环，取值范围从0到2^32-1。将每个服务器节点通过hash映射到环上，同时将数据key通过hash函数也映射到环上，按顺时针方向，数据key跟哪个节点近就属于哪个节点。&lt;&#x2F;p&gt;
&lt;p&gt;举个例子，现在有三个缓存服务器节点2，4，6，假设这个hash算法就是原样输出，我们将节点和数据（1，3，7，9）经过hash之后到环上：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;0082zybply1gc53lsij1jj30b3079glv.jpg&quot; alt=&quot;一致性hash&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;按顺时针方向，数据1属于node2，数据3属于node4，数据7、9输入node6。&lt;&#x2F;p&gt;
&lt;p&gt;貌似看起来不错，但是还有个问题。在节点较少的情况上，会发生 &lt;strong&gt;数据倾斜&lt;&#x2F;strong&gt; 的问题。比如上图所示，数据可能大量的堆积在node6和node2之间。&lt;&#x2F;p&gt;
&lt;p&gt;解决办法是添加虚拟节点，利用虚拟节点负载均衡每个数据。虚拟节点的做法是，对一个真实节点计算多个hash，放到环上，所有这些虚拟节点的数据都属于真实节点。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;0082zybply1gc54o5rm70j30ax06xwf4.jpg&quot; alt=&quot;一致性hash2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这样所有的数据都均匀的分布在环上了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;suan-fa-shi-xian&quot;&gt;算法实现&lt;&#x2F;h2&gt;
&lt;p&gt;了解了原理，来动手实现一下一致性hash算法。整个算法模仿go语言的分布式缓存服务&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;groupcache&quot;&gt;groupcache&lt;&#x2F;a&gt; 实现，groupcache可以说是&lt;strong&gt;memcached&lt;&#x2F;strong&gt; 的go语言实现。&lt;&#x2F;p&gt;
&lt;p&gt;首先定义一致性hash环结构体：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Hash &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;data &lt;&#x2F;span&gt;&lt;span&gt;[]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;byte&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;uint32
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ConHash 一致性hash
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;ConHash &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hash     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Hash           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; hash算法
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;replicas &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 虚拟节点数
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodes    &lt;&#x2F;span&gt;&lt;span&gt;[]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; hash环节点数
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hashMap  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;string &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 虚拟节点-真实节点
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到，类型Hash就是个回调函数，用户可以自定义hash算法。&lt;&#x2F;p&gt;
&lt;p&gt;然后需要往hash环上添加节点，根据指定的虚拟节点数用hash算法放到环上。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Add 添加节点到hash环上
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ConHash&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Add&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodes &lt;&#x2F;span&gt;&lt;span&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;node &lt;&#x2F;span&gt;&lt;span&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;range &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodes &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 将节点值根据指定的虚拟节点数利用hash算法放置到环中
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i &lt;&#x2F;span&gt;&lt;span&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;replicas&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i&lt;&#x2F;span&gt;&lt;span&gt;++ {
&lt;&#x2F;span&gt;&lt;span&gt;			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h &lt;&#x2F;span&gt;&lt;span&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hash&lt;&#x2F;span&gt;&lt;span&gt;([]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;byte&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;strconv&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Itoa&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i&lt;&#x2F;span&gt;&lt;span&gt;) + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodes &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;append&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodes&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 映射虚拟节点到真实节点
&lt;&#x2F;span&gt;&lt;span&gt;			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hashMap&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h&lt;&#x2F;span&gt;&lt;span&gt;] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;node
&lt;&#x2F;span&gt;&lt;span&gt;		}
&lt;&#x2F;span&gt;&lt;span&gt;	}
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sort&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Ints&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodes&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;同样还需要根据key值从环上获取对应的节点，获取到节点之后从该节点查找数据。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Get 从hash环上获取key对应的节点
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ConHash&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Get&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;key &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;string &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodes&lt;&#x2F;span&gt;&lt;span&gt;) == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;	}
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 计算key的hash值
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h &lt;&#x2F;span&gt;&lt;span&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hash&lt;&#x2F;span&gt;&lt;span&gt;([]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;byte&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;key&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 顺时针找到第一个匹配的虚拟节点
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;idx &lt;&#x2F;span&gt;&lt;span&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sort&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Search&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodes&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodes&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i&lt;&#x2F;span&gt;&lt;span&gt;] &amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h
&lt;&#x2F;span&gt;&lt;span&gt;	})
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 从hash环查找
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 返回hash映射的真实节点
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hashMap&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodes&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;idx&lt;&#x2F;span&gt;&lt;span&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nodes&lt;&#x2F;span&gt;&lt;span&gt;)]]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有的人说不对啊，为啥添加的都是服务器节点，数据不是也放在环上吗？&lt;&#x2F;p&gt;
&lt;p&gt;其实是因为groupcache将数据划分出一个group的概念，数据在内部存储上利用hash+双向链表实现，缓存的数据被放在链表中。&lt;&#x2F;p&gt;
&lt;p&gt;整个流程是这样的，查找key值对应的数据时，根据url链接中的group和key值确定节点，如何确定的？上面的代码已经解释了，计算key值的hash，看它属于哪个节点。&lt;&#x2F;p&gt;
&lt;p&gt;然后从该节点的双向链表中查找。如果节点不存在这个key，从用户定义的数据源查找（比如数据库），找到之后将数据存入该group中。&lt;&#x2F;p&gt;
&lt;p&gt;以上，希望有帮助。&lt;&#x2F;p&gt;
</content>
    </entry>
    <entry xml:lang="en">
        <title>对Raft一致性算法的理解</title>
        <published>2019-08-21T22:02:53+08:00</published>
        <updated>2019-08-21T22:02:53+08:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://chaojie.fun/articles/dui-raft-yi-zhi-xing-suan-fa-de-li-jie/" type="text/html"/>
        <id>https://chaojie.fun/articles/dui-raft-yi-zhi-xing-suan-fa-de-li-jie/</id>
        <content type="html"></content>
    </entry>
</feed>
